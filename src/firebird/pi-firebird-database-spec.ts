import { PiDatabase } from "@pomgui/database";
import { PiFirebirdPool } from './pi-firebird-pool';
import { GDSCode } from 'node-firebird/lib/gdscodes';

describe('PiFirebirdDatabase', () => {
    let pool: PiFirebirdPool;
    let db: PiDatabase;

    beforeEach(() => {
        process.env.LOG_LEVEL = 'OFF';
        pool = new PiFirebirdPool({
            database: '/firebird/data/test/test01.fdb',
            host: '127.0.0.1',
            user: 'sysdba',
            password: 'masterkey',
            port: 3050
        }, 4);
    });

    describe('open/close', () => {
        it('should get a connection from pool and release it', async () => {
            db = await pool.get();
            await db.close();
        });
    });

    describe('Database operations without transaction', () => {
        beforeEach(async () => db = await pool.get());
        afterEach(async () => await db.close());

        test({
            sql: `
            recreate table spec_test(
                test_id int generated by default as identity not null primary key, 
                string_val varchar(10),
                int_val int
            )`, expected: undefined
        });
        test({ sql: 'insert into spec_test(string_val, int_val) values (:values) returning test_id as new_id', params: { values: ['oldval', 1] }, expected: [{ newId: 1 }] });
        test({ sql: 'select count(*) qtd_rows from spec_test', expected: [{ qtdRows: 1 }] });
        test({ sql: 'update spec_test set string_val = :val where test_id = 1', params: { val: 'newval' }, expected: undefined });
        test({ sql: 'select * from spec_test', expected: [{ testId: 1, stringVal: 'newval', intVal: 1 }] });
        test({ sql: 'delete from spec_test where test_id = :id', params: [{ id: 1 }], expected: undefined });
    });

    describe('Database operations with commited transaction', () => {
        beforeEach(async () => db = await pool.get());
        afterEach(async () => { await db.close(); });
        test({
            sql: `
            recreate table spec_test(
                test_id int generated by default as identity not null primary key, 
                string_val varchar(10),
                int_val int
            )`, expected: undefined, lastOp: 'commit'
        });
        test({ sql: 'insert into spec_test(string_val, int_val) values (:values) returning test_id as new_id', params: { values: ['oldval', 1] }, expected: [{ newId: 1 }], lastOp: 'commit' });
        test({ sql: 'select count(*) qtd_rows from spec_test', expected: [{ qtdRows: 1 }], lastOp: 'commit' });
        test({ sql: 'update spec_test set string_val = :val where test_id = 1', params: { val: 'newval' }, expected: undefined, lastOp: 'rollback' });
        test({ sql: 'select * from spec_test', expected: [{ testId: 1, stringVal: 'oldval', intVal: 1 }], lastOp: 'commit' });
        test({ sql: 'delete from spec_test where test_id = :id', params: [{ id: 1 }], expected: undefined, lastOp: 'commit' });
    });

    describe('Database operations with errors', () => {
        beforeEach(async () => db = await pool.get());
        afterEach(async () => { await db.close(); });
        test({
            sql: `
            recreate table spec_test(
                test_id int generated by default as identity not null primary key, 
                string_val varchar(10),
                int_val int
            )
            `, expected: undefined, lastOp: 'commit'
        });
        test({ title: 'Normal insert', sql: 'insert into spec_test(string_val, int_val) values (:values) returning test_id as new_id', params: { values: ['oldval', 1] }, expected: [{ newId: 1 }], lastOp: 'commit' });
        test({
            title: 'pk duplicada',
            sql: 'insert into spec_test(test_id, string_val) values (:id, :str) returning test_id as new_id',
            params: { id: 1, str: 'new value' },
            error: 'UNIQUE_KEY_VIOLATION'
        });
    });


    function test(p: { title?: string, sql: string, params?: any, expected?: any, lastOp?: 'commit' | 'rollback', error?: string }) {
        const type = /\w+/.exec(p.sql)![0];
        if (!p.title)
            p.title = 'should execute> ' + type + (p.lastOp ? 'with ' + p.lastOp : '');
        it(p.title, async () => {
            let intf = (db as any)._db;
            if (p.lastOp !== undefined) {
                await db.beginTransaction();
                intf = (db as any)._currTransac;
            }

            spyOn(intf, 'query').and.callThrough();

            let result;
            try {
                result = await db.query(p.sql, p.params);
                expect(result).toEqual(p.expected);
            } catch (e) {
                if (p.error)
                    expect(e.gdscode).toEqual(GDSCode[p.error]);
                else throw e;
            }

            expect(intf.query).toHaveBeenCalled();

            if (p.lastOp == 'commit')
                await db.commit();
            else if (p.lastOp == 'rollback')
                await db.rollback();
        });
    }
});